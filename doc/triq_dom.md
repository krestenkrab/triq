Module triq_dom
===============


<h1>Module triq_dom</h1>

* [Data Types](#types)
* [Function Index](#index)
* [Function Details](#functions)






<h2><a name="types">Data Types</a></h2>


<a name="type-domain"></a>


<h3 class="typedecl">domain()</h3>

<b>abstract datatype</b>: <tt>domain(T)</tt>

Domain of values of type T.

<a name="type-pick_fun"></a>


<h3 class="typedecl">pick_fun()</h3>

<b>abstract datatype</b>: <tt>pick_fun(T)</tt>

Picks members of the `domain(T)`.
Return pair of `{domain(T),T}`; the "output domain" is what will
be used for shrinking the value.
<a name="type-shrink_fun"></a>


<h3 class="typedecl">shrink_fun()</h3>

<b>abstract datatype</b>: <tt>shrink_fun(T)</tt>

Shrinks members of the `domain(T)`.
Return pair of `{domain(T),T}`; the "output domain" is what will
be used for further shrinking the value.

<h2><a name="index">Function Index</a></h2>



<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#any-0">any/0</a></td><td></td></tr><tr><td valign="top"><a href="#atom-0">atom/0</a></td><td></td></tr><tr><td valign="top"><a href="#atom-1">atom/1</a></td><td></td></tr><tr><td valign="top"><a href="#binary-0">binary/0</a></td><td></td></tr><tr><td valign="top"><a href="#binary-1">binary/1</a></td><td></td></tr><tr><td valign="top"><a href="#bool-0">bool/0</a></td><td>The domain of booleans.</td></tr><tr><td valign="top"><a href="#char-0">char/0</a></td><td></td></tr><tr><td valign="top"><a href="#choose-2">choose/2</a></td><td></td></tr><tr><td valign="top"><a href="#domain-3">domain/3</a></td><td>Create custom domain.</td></tr><tr><td valign="top"><a href="#elements-1">elements/1</a></td><td>Generates a member of the list <code>L</code>.</td></tr><tr><td valign="top"><a href="#eval-1">eval/1</a></td><td>Evaluate <code>Body</code>.</td></tr><tr><td valign="top"><a href="#eval-2">eval/2</a></td><td>Evaluate <code>Body</code>, replacing occurrences of <code>{call,M,F,A}</code> and <code>{var,N}</code>.</td></tr><tr><td valign="top"><a href="#frequency-1">frequency/1</a></td><td>Choose domain from list [{Weight, Domain}, ...].</td></tr><tr><td valign="top"><a href="#int-0">int/0</a></td><td>The domain of integers.</td></tr><tr><td valign="top"><a href="#list-1">list/1</a></td><td>
Returns the domain of lists of the argument.</td></tr><tr><td valign="top"><a href="#non_empty-1">non_empty/1</a></td><td></td></tr><tr><td valign="top"><a href="#oneof-1">oneof/1</a></td><td></td></tr><tr><td valign="top"><a href="#open-1">open/1</a></td><td>Open a box, yielding a domain which always generates the same value.</td></tr><tr><td valign="top"><a href="#peek-1">peek/1</a></td><td></td></tr><tr><td valign="top"><a href="#pick-2">pick/2</a></td><td>The heart of the random structure generator; pick a value from the domain.</td></tr><tr><td valign="top"><a href="#real-0">real/0</a></td><td>The domain of floats.</td></tr><tr><td valign="top"><a href="#resize-2">resize/2</a></td><td></td></tr><tr><td valign="top"><a href="#return-1">return/1</a></td><td>Returns the domain containing exactly <code>Value</code>.</td></tr><tr><td valign="top"><a href="#sample-1">sample/1</a></td><td>
Generate a sample of output values from a generator.</td></tr><tr><td valign="top"><a href="#sampleshrink-1">sampleshrink/1</a></td><td>Print a value generated by <code>Domain</code>, followed by a sample of shrinkings.</td></tr><tr><td valign="top"><a href="#seal-1">seal/1</a></td><td>Get the domain of boxes of T.</td></tr><tr><td valign="top"><a href="#shrink-2">shrink/2</a></td><td>The shrinking step function used internally in Triq.</td></tr><tr><td valign="top"><a href="#shrink_without_duplicates-1">shrink_without_duplicates/1</a></td><td></td></tr><tr><td valign="top"><a href="#sized-1">sized/1</a></td><td>Support function for the ?SIZED macro.</td></tr><tr><td valign="top"><a href="#tuple-1">tuple/1</a></td><td></td></tr><tr><td valign="top"><a href="#vector-2">vector/2</a></td><td></td></tr></table>


<a name="functions"></a>


<h2>Function Details</h2>


<a name="any-0"></a>


<h3>any/0</h3>





`any() -> any()`


<a name="atom-0"></a>


<h3>atom/0</h3>





`atom() -> any()`


<a name="atom-1"></a>


<h3>atom/1</h3>





`atom(Size) -> any()`


<a name="binary-0"></a>


<h3>binary/0</h3>





`binary() -> any()`


<a name="binary-1"></a>


<h3>binary/1</h3>





`binary(Size) -> any()`


<a name="bool-0"></a>


<h3>bool/0</h3>





<tt>bool() -> <a href="#type-domain">domain(true | false)</a></tt>



The domain of booleans.  Shrinks to false.
<a name="char-0"></a>


<h3>char/0</h3>





`char() -> any()`


<a name="choose-2"></a>


<h3>choose/2</h3>





`choose(M, N) -> any()`


<a name="domain-3"></a>


<h3>domain/3</h3>





<tt>domain(Name::any(), PickFun::<a href="#type-pick_fun">pick_fun(T)</a>, ShrinkFun::<a href="#type-shrink_fun">shrink_fun(T)</a>) -> <a href="#type-domain">domain(T)</a></tt>





Create custom domain.  
This function allows you to create a custom domain with it's own  
shrinking logic.  For instance, the even numbers can be specified thus:


<pre>even() ->
domain(even,
fun(Self,Size) ->
Value = (rand:uniform(Size) * 2) div 2,
{Self, Value}
end,
fun(Self,Value) when Value>0 ->
{Self, Value-2};
(Self,_,0) ->
{0, 0}
end).</pre>




The domain itself (`Self` in the above code) is passed as the first argument  
to each invocation of both the picking and the shrinking functions.

Both the picking and the shrinking function must return a 2-tuple of
the domain of the resulting value, and the value itself.

<a name="elements-1"></a>


<h3>elements/1</h3>





<tt>elements(L::[any()]) -> <a href="#type-domain">domain(any())</a></tt>



Generates a member of the list `L`.  Shrinks towards the first element of the list.
<a name="eval-1"></a>


<h3>eval/1</h3>





<tt>eval(Body::any()) -> any()</tt>



Equivalent to [`eval([], Body)`](#eval-2).



Evaluate `Body`.  Occurrences of `{call,M,F,A}`
is replaced by the result of calling `erlang:apply(M,F,A)`, and
occurrences of `{var,Name}` in `Body` are not substituted.

This is a plain function, not a compile_transform or anything like that,
so nested functions are not traversed in the substitution.  However, nested
occurrences of `{call,M,F,A}` are substituted as one would think:
depth first, left-to-right.

<a name="eval-2"></a>


<h3>eval/2</h3>





<tt>eval(PropList::[{atom(), any()}], Body::any()) -> any()</tt>





Evaluate `Body`, replacing occurrences of `{call,M,F,A}` and `{var,N}`.
Occurrences of `{call,M,F,A}` is replaced by `erlang:apply(M,F,A)`, and
`{var,Name}` is replaced by the value with key `Name` in `PropList`.



Exceptions happening when calling `erlang:apply/3` are not caught.
If `Name` is unbound i.e., `Name` does not appear in `PropList` or if
`Name` is not an atom, `{var,Name}` is unchanged.

This is a plain function, not a compile_transform or anything like that,
so nested functions are not traversed in the substitution.  However, nested
occurrences of `{call,M,F,A}` are substituted as one would think:
depth first, left-to-right.

<a name="frequency-1"></a>


<h3>frequency/1</h3>





`frequency(GenList) -> any()`



Choose domain from list [{Weight, Domain}, ...]
<a name="int-0"></a>


<h3>int/0</h3>





<tt>int() -> <a href="#type-domain">domain(integer())</a></tt>



The domain of integers.
<a name="list-1"></a>


<h3>list/1</h3>





<tt>list(ElemDom::<a href="#type-domain">domain(T)</a>) -> <a href="#type-domain">domain([T])</a></tt>




Returns the domain of lists of the argument.
For example, `list(int())` yields the domain of lists of integers.

<a name="non_empty-1"></a>


<h3>non_empty/1</h3>





`non_empty(?DOM) -> any()`


<a name="oneof-1"></a>


<h3>oneof/1</h3>





`oneof(DomList) -> any()`


<a name="open-1"></a>


<h3>open/1</h3>





<tt>open(?BOX::<a href="#type-box">box(T)</a>) -> <a href="#type-domain">domain(T)</a></tt>



Open a box, yielding a domain which always generates the same value.
<a name="peek-1"></a>


<h3>peek/1</h3>





`peek(?BOX) -> any()`


<a name="pick-2"></a>


<h3>pick/2</h3>





<tt>pick(Dom::<a href="#type-domain">domain(T)</a>, SampleSize::<a href="#type-pos_integer">pos_integer()</a>) -> {<a href="#type-domain">domain(T)</a>, T}</tt>



The heart of the random structure generator; pick a value from the domain.
Returns a pair of `{domain(T), T}` where the first component describes
the structure of the picked value.
<a name="real-0"></a>


<h3>real/0</h3>





<tt>real() -> <a href="#type-domain">domain(float())</a></tt>



The domain of floats.
<a name="resize-2"></a>


<h3>resize/2</h3>





`resize(Sz, Dom) -> any()`


<a name="return-1"></a>


<h3>return/1</h3>





<tt>return(Value::Type) -> <a href="#type-domain">domain(Type)</a></tt>



Returns the domain containing exactly `Value`.
Triq uses internally records of type `@`; and so to avoid
interpretation of such values you can wrap it with this.  This would
be the case if you have constants in your domains contain the atom `@`.
I.e., the following would break because Triq tries to interpret the `@`:

<pre>?FORALL(X, [int(), {'@', 4}],
[IntVal, {'@', 4}] = X
)</pre>

To fix it, do like this:

<pre>?FORALL(X, [int(), return({'@', 4})],
[IntVal, {'@', 4}] = X
)</pre>

<a name="sample-1"></a>


<h3>sample/1</h3>





<tt>sample(Dom::<a href="#type-domain">domain(T)</a>) -> [T]</tt>




Generate a sample of output values from a generator.

<a name="sampleshrink-1"></a>


<h3>sampleshrink/1</h3>





<tt>sampleshrink(Domain::<a href="#type-domain">domain(any())</a>) -> ok</tt>





Print a value generated by `Domain`, followed by a sample of shrinkings.  
For each line of successive output, it prints up to five samples of  
shrinking.  The first value on each like is used as the target for the next  
round of shrinking.


<pre> 1> sampleshrink(list(int())).
[-2,-8,2]
[[-1,-8,2],[0,-8,2],[-1,-7,2],[-2,-8,1],[-1,-8,1]]
[[0,-8,2],[0,-6,1],[-1,-7,2],[0,-7,2]]
[[0,-8,0],[0,-7,0],[0,-7,2],[0,-8,1],[0,-5,2],[0,-7,1]]
[[0,-7,0],[0,-5,0]]
[[0,-5,0],[0,-6,0]]
[[0,-4,0],[0,-3,0]]
[[0,-2,0],[0,-3,0],[0,-1,0]]
[[0,-1,0]]
[[0,0,0]]
[[0,0]]
[[0]]
[[]]
ok</pre>

<a name="seal-1"></a>


<h3>seal/1</h3>





<tt>seal(Dom::<a href="#type-domain">domain(T)</a>) -> <a href="#type-domain">domain(<a href="#type-box">box(T)</a>)</a></tt>



Get the domain of boxes of T
<a name="shrink-2"></a>


<h3>shrink/2</h3>





<tt>shrink(Domain::<a href="#type-domain">domain(T)</a>, Value::T) -> {<a href="#type-domain">domain(T)</a>, T}</tt>





The shrinking step function used internally in Triq.



Performs one single step of shrinking.  If unsuccessful,  
i.e. value cound not be shrunk, the output is equal to the input.

Takes a `Domain` and a `Value` from said domain, and shrinks
the value within the constraints of the domain.  The result is
a tuple of a (possibly smaller) output domain, and the
shrunken value.

<a name="shrink_without_duplicates-1"></a>


<h3>shrink_without_duplicates/1</h3>





`shrink_without_duplicates(Dom) -> any()`


<a name="sized-1"></a>


<h3>sized/1</h3>





<tt>sized(Fun::<a href="#type-fun">'fun'((integer()) -> <a href="#type-domain">domain(T)</a>)</a>) -> <a href="#type-domain">domain(T)</a></tt>



Support function for the ?SIZED macro.
<a name="tuple-1"></a>


<h3>tuple/1</h3>





<tt>tuple(ElemDom::<a href="#type-domain">domain(ElemType::any())</a>) -> <a href="#type-domain">domain(tuple(ElemType))</a></tt>


<a name="vector-2"></a>


<h3>vector/2</h3>





`vector(Size, ElemDom) -> any()`



_Generated by EDoc, Nov 7 2010, 11:39:46._